<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Toddler Morning Schedule</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #f5f5f5;
      -webkit-user-select: none;
      touch-action: none;
    }

    #clock {
      position: fixed;
      top: 10px;
      right: 100px;
      font-size: 2rem;
      background: #222;
      color: #0f0;
      padding: 10px 20px;
      border-radius: 10px;
      font-family: "Courier New", monospace;
      z-index: 50;
    }

    #version {
      position: fixed;
      left: 10px;
      top: 10px;
      font-size: 14px;
      opacity: 0.4;
      cursor: pointer;
      z-index: 50;
      user-select: none;
    }

    .timeline-container {
      position: relative;
      width: 100%;
      overflow-x: hidden;
      margin: 0;
    }

    .timeline {
      position: relative;
      border-top: 4px solid #444;
      background: linear-gradient(180deg, rgba(0,0,0,0.02), transparent);
    }

    .time-label {
      position: absolute;
      top: 20px;
      font-weight: bold;
      color: #ff6600;
      font-size: 24px;
    }

    .bubble {
      position: absolute;
      padding: 10px 15px;
      background: #fff;
      border-radius: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      text-align: center;
      cursor: grab;
      user-select: none;
      -webkit-user-drag: none;
      transition: transform 0.15s ease;
      touch-action: none;
    }

    .bubble:active { cursor: grabbing }

    .current-line {
      position: absolute;
      top: 0;
      width: 2px;
      height: 100%;
      background: red;
      z-index: 40;
      pointer-events: none;
    }

    #debugMenu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.95);
      overflow-y: auto;
      padding: 20px 20px 60px 20px; /* add bottom padding */
      font-size: 14px;
      display: none;
      z-index: 9999;
    }

    #debugMenu h2 { margin-top: 0; }
    #debugMenu input { margin: 2px 0; padding: 4px; width: 100%; font-size: 14px; }
    #debugMenu button { margin: 4px 0; padding: 6px; font-size: 14px; }

    @media (max-width: 600px) {
      #clock { font-size: 1.4rem }
    }
  </style>
</head>
<body>
  <div id="version">v5</div>
  <div id="clock">00:00:00</div>

  <div id="debugMenu">
    <div>Canvas Height: <span id="canvasHeight"></span> px</div>
    <div>Bubble count: <span id="bubbleCount"></span></div>
    <div style="margin-top:6px; font-size:12px">Bubble Y positions:</div>
    <div id="bubblePositions" style="max-height:140px; overflow:auto; font-family:monospace; font-size:12px; margin-top:4px"></div>
    <h2>Bubble Editor</h2>
    <button id="addBubble">Add Bubble</button>
    <button id="closeDebug">Close Editor</button>
    <div id="bubbleEditor"></div>
  </div>

  <div class="timeline-container" id="timelineContainer">
    <div class="timeline" id="timeline">
      <div class="current-line" id="currentLine"></div>
      <div class="time-label" style="left:0%">7:00</div>
      <div class="time-label" style="right:0%">8:00</div>

      <div class="bubble" data-start="7:00" data-end="7:10">ðŸŒ…ðŸš½ Wake Up<br>7:00â€“7:10</div>
      <div class="bubble" data-start="7:10" data-end="7:30">ðŸ¥£ Breakfast<br>7:10â€“7:30</div>
      <div class="bubble" data-start="7:30" data-end="7:40">ðŸ‘•ðŸ‘– Get Dressed<br>7:30â€“7:40</div>
      <div class="bubble" data-start="7:40" data-end="7:45">ðŸª¥ Brush Teeth<br>7:40â€“7:45</div>
      <div class="bubble" data-start="7:45" data-end="7:50">ðŸ§¥ðŸ‘Ÿ Shoes & Jacket<br>7:45â€“7:50</div>
      <div class="bubble" data-start="7:50" data-end="8:00">ðŸš— Get in Car<br>7:50â€“8:00</div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let autoGrid = true;
      const clockEl = document.getElementById('clock');
      const timelineEl = document.getElementById('timeline');
      const timelineContainer = document.getElementById('timelineContainer');
      const currentLine = document.getElementById('currentLine');
      const bubbleCountEl = document.getElementById('bubbleCount');
      const bubblePositionsEl = document.getElementById('bubblePositions');
      const versionEl = document.getElementById('version');
      const debugMenu = document.getElementById('debugMenu');
      const canvasHeightEl = document.getElementById('canvasHeight');
      const bubbleEditor = document.getElementById('bubbleEditor');
      const closeDebug = document.getElementById('closeDebug');
      const addBubbleBtn = document.getElementById('addBubble');

      let bubbles = Array.from(document.querySelectorAll('.bubble'));

      function updateClock() {
        const now = new Date();
        const hh = String(now.getHours()).padStart(2,'0');
        const mm = String(now.getMinutes()).padStart(2,'0');
        const ss = String(now.getSeconds()).padStart(2,'0');
        clockEl.textContent = `${hh}:${mm}:${ss}`;
      }
      setInterval(updateClock,1000); updateClock();

      function timeToPercent(timeStr) {
        const [h,m] = timeStr.split(':').map(Number);
        return ((h + m/60 - 7) / 1) * 100;
      }
      
      function resizeTimeline() {
        const padding = 40;
        timelineEl.style.height = (window.innerHeight - padding*2) + 'px';
        computeGrid();
        updateCurrentLine();
      }

      function computeGrid() {
        const containerRect = timelineEl.getBoundingClientRect();
        const padding = Math.max(40, containerRect.height*0.16);
        const usableHeight = Math.max(100, containerRect.height - padding*2);
        const step = usableHeight / Math.max(1,bubbles.length -1);

        bubbles.forEach((b,i) => {
          const top = padding + i*step - (b.getBoundingClientRect().height/2);
          b.style.top = top + 'px';

          const start = b.dataset.start || '7:00';
          const end = b.dataset.end || '7:15';
          const leftPercent = timeToPercent(start);
          const rightPercent = timeToPercent(end);
          const widthPercent = Math.max(5, rightPercent - leftPercent);
          b.style.left = leftPercent + '%';
          b.style.width = widthPercent + '%';

          b.dataset.origTop = top;
          b.dataset.origLeft = b.style.left;
          b.dataset.origWidth = b.style.width;
        });

        canvasHeightEl.textContent = Math.round(containerRect.height);
        bubbleCountEl.textContent = bubbles.length;
        bubblePositionsEl.innerHTML = bubbles.map((b,j)=>`${j+1}: top=${Math.round(parseFloat(b.dataset.origTop))}px, left=${b.dataset.origLeft}, width=${b.dataset.origWidth}`).join('<br>');
      }

      function updateCurrentLine() {
        const now = new Date();
        const hours = now.getHours() + now.getMinutes()/60 + now.getSeconds()/3600;
        if(hours < 7 || hours > 8) {
          currentLine.style.display='none';
          return;
        } else {
          currentLine.style.display='block';
        }
        const percent = ((hours-7)/1)*100;
        const timelineWidth = timelineEl.getBoundingClientRect().width;
        currentLine.style.left = (timelineWidth * percent/100) + 'px';
        currentLine.style.height = timelineEl.getBoundingClientRect().height + 'px';
      }

      setInterval(updateCurrentLine,1000);
      setInterval(() => { if(autoGrid) computeGrid(); }, 3000);

      window.addEventListener('resize', resizeTimeline);
      window.addEventListener('orientationchange', resizeTimeline);
      resizeTimeline();

function renderDebugMenu() {
  bubbleEditor.innerHTML = '';
  // Toggle computeGrid
  const toggleDiv = document.createElement('div');
  toggleDiv.style.marginBottom = '12px';
  const toggleLabel = document.createElement('label');
  toggleLabel.style.fontWeight = 'bold';
  toggleLabel.textContent = 'Auto Grid Updates: ';
  const toggleInput = document.createElement('input');
  toggleInput.type = 'checkbox';
  toggleInput.checked = autoGrid;
  toggleInput.style.marginLeft = '6px';
  toggleInput.addEventListener('change', () => { autoGrid = toggleInput.checked; });
  toggleLabel.appendChild(toggleInput);
  toggleDiv.appendChild(toggleLabel);
  bubbleEditor.appendChild(toggleDiv);
  
  bubbles.forEach((b, i) => {
    const div = document.createElement('div');
    div.style.border = '1px solid #ccc';
    div.style.marginBottom = '8px';
    div.style.padding = '4px';

    // Bubble text
    const textInput = document.createElement('input');
    textInput.value = b.innerHTML;
    textInput.addEventListener('input', () => { b.innerHTML = textInput.value; });

    // Top (Y position)
    const topInput = document.createElement('input');
    topInput.type = 'number';
    topInput.value = parseFloat(b.style.top);
    topInput.placeholder = 'Y (px)';
    topInput.addEventListener('input', () => { b.style.top = topInput.value + 'px'; });

    // Left (X position)
    const xInput = document.createElement('input');
    xInput.type = 'number';
    xInput.value = parseFloat(b.style.left);
    xInput.placeholder = 'X (px)';
    xInput.addEventListener('input', () => { b.style.left = xInput.value + 'px'; });

    // Data-start
    const startInput = document.createElement('input');
    startInput.type = 'text';
    startInput.value = b.dataset.start || '';
    startInput.placeholder = 'data-start (HH:MM)';
    startInput.addEventListener('input', () => { b.dataset.start = startInput.value; computeGrid(); });

    // Data-end
    const endInput = document.createElement('input');
    endInput.type = 'text';
    endInput.value = b.dataset.end || '';
    endInput.placeholder = 'data-end (HH:MM)';
    endInput.addEventListener('input', () => { b.dataset.end = endInput.value; computeGrid(); });

    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    deleteBtn.addEventListener('click', () => {
      b.remove();
      bubbles = bubbles.filter(x => x !== b);
      renderDebugMenu();
    });

    div.appendChild(document.createTextNode(`Bubble ${i+1}`));
    div.appendChild(textInput);
    div.appendChild(topInput);
    div.appendChild(xInput);
    div.appendChild(startInput);
    div.appendChild(endInput);
    div.appendChild(deleteBtn);
    bubbleEditor.appendChild(div);

  });

  // Save button for positions
  const saveBtn = document.createElement('button');
  saveBtn.textContent = 'Save Positions';
  saveBtn.addEventListener('click', () => {
    bubbles.forEach(b => {
      b.dataset.origTop = parseFloat(b.style.top);
      b.dataset.origLeft = b.style.left;
    });
    alert('Bubble positions saved!');
  });
  bubbleEditor.appendChild(saveBtn);

  // Bottom spacer to prevent cutoff
  const spacer = document.createElement('div');
  spacer.style.height = '80px'; // ensures extra room at bottom
  bubbleEditor.appendChild(spacer);

}


      // Make dynamically added bubbles draggable
function makeDraggable(bubble) {
  bubble.addEventListener('touchstart', startDrag, {passive:false});
  bubble.addEventListener('touchmove', onDrag, {passive:false});
  bubble.addEventListener('touchend', endDrag);
  bubble.addEventListener('touchcancel', endDrag);
  bubble.addEventListener('mousedown', e => {
    e.preventDefault();
    startDrag(e);
    const m = ev => onDrag(ev);
    const u = () => { endDrag(); window.removeEventListener('mousemove', m); window.removeEventListener('mouseup', u); };
    window.addEventListener('mousemove', m);
    window.addEventListener('mouseup', u);
  });
}

            // Drag & drop code remains unchanged
      let dragItem=null,offsetX=0,offsetY=0;
      function startDrag(e){if(e.cancelable)e.preventDefault();dragItem=e.currentTarget;dragItem.style.zIndex=999;const t=(e.touches&&e.touches[0])||e;const r=dragItem.getBoundingClientRect();offsetX=t.clientX-r.left;offsetY=t.clientY-r.top;dragItem.style.transition='';dragItem.style.transform='scale(1.03)';}
      function onDrag(e){if(!dragItem)return;if(e.cancelable)e.preventDefault();const t=(e.touches&&e.touches[0])||e;const x=t.clientX-offsetX;const y=t.clientY-offsetY;const tr=timelineEl.getBoundingClientRect();const br=dragItem.getBoundingClientRect();let nx=x;if(nx<tr.left)nx=tr.left;if(nx+br.width>tr.right)nx=tr.right-br.width;dragItem.style.left=(nx-tr.left)+'px';dragItem.style.top=y+'px';}
      function endDrag(){if(!dragItem)return;const origTop=parseFloat(dragItem.dataset.origTop)||0;const origLeft=dragItem.dataset.origLeft||'0%';const origWidth=dragItem.dataset.origWidth||'50px';dragItem.style.transition='left 0.6s ease, top 0.6s ease, width 0.6s ease, transform 0.2s ease';dragItem.style.left=origLeft;dragItem.style.top=origTop+'px';dragItem.style.width=origWidth;dragItem.style.transform='';const tc=dragItem;setTimeout(()=>{if(!tc)return;tc.style.transition='';tc.style.zIndex='';},650);dragItem=null;}
      bubbles.forEach(b=>{b.addEventListener('touchstart',startDrag,{passive:false});b.addEventListener('touchmove',onDrag,{passive:false});b.addEventListener('touchend',endDrag);b.addEventListener('touchcancel',endDrag);b.addEventListener('mousedown',e=>{e.preventDefault();startDrag(e);const m=ev=>onDrag(ev);const u=()=>{endDrag();window.removeEventListener('mousemove',m);window.removeEventListener('mouseup',u);};window.addEventListener('mousemove',m);window.addEventListener('mouseup',u);});});

      addBubbleBtn.addEventListener('click', () => {
        const newBubble = document.createElement('div');
        newBubble.className = 'bubble';
        newBubble.dataset.start = '7:00';
        newBubble.dataset.end = '7:05';
        newBubble.innerHTML = 'New Bubble<br>7:00â€“7:05';
        timelineEl.appendChild(newBubble);
        bubbles.push(newBubble);
        makeDraggable(newBubble);
        renderDebugMenu();
      });
      bubbles.forEach(b => makeDraggable(b));
      
      versionEl.addEventListener('click', () => {
        debugMenu.style.display = 'block';
        renderDebugMenu();
      });

      closeDebug.addEventListener('click', () => { debugMenu.style.display = 'none'; });
    });
  </script>
</body>
</html>
